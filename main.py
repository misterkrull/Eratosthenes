# Удалил лишние комментарии от какой-то левой системы

# 1. Отделил вывод простых чисел отдельно от всего остального интерфейса. 
#    Если делать по красоте, то функция не должна ничего печатать, а просто возвращать список простых чисел.
#    Вывод данных это отедльная функция, которая должна отдельно происходить. 
#    Но будем считать, что здесь это сделано для оптимизации, хотя получилось немного по-говнянски.

# 2. Также переименовал функцию в snake-case согласно PEP8.
# 3. Добавил аннотации типов в функцию. В целом это не обязательно, но добавлять лучше чем не добавлять. 
# 4. Добавил docstring к функции.
def sieve_of_eratosthenes(n: int) -> int:
    """ 
        Функция печатает простые числа в интервале от 2 до n
        и возвращает величину k_max_pereimenovat для которой пока не придумано хорошее название.
    """
    is_prime = [True] * (n+1)  # Это показывал на созвоне, список из bool, заменил все значение 0 и 1 на bool дальше по коду
    k_max_pereimenovat = 0  # Для k_max_pereimenovat лучше найти какое-то вменяемое название, которое будет отражать его сущность ибо название "k_max_pereimenovat" ни о чем не говорит читателю.
    # TODO: постараться придумать более лучшее название для k_max_pereimenovat

    for k in range(2, n+1):
        if not is_prime[k]:
            # Чтобы уменьшить количество уровней вложенности обратил условие и использовал continue
            # Длинные лестницы из уровней вложенности это плохой тон, если можно избавиться лучше избавиться.
            continue
        
        # Сразу печатаю число, не занося его ни в какую в строку. Использую специальный аргумент у print, чтобы он не переносил строку.
        print(k, end=' ')
        
        # Использовал цикл for вместо while, что позволило выкинуть 2 лишние строчки   ---- улучшилась ли читаемость? мне кажется, что раньше лучше было
        for i in range(k, n // k + 1):
            if is_prime[i*k]:
                k_max_pereimenovat = k  # Здесь max не нужен, т.к. k у нас растет только вперед и он никогда не может быть меньще k_max_pereimenovat   ---- ну... да)
                is_prime[i*k] = False
    
    return k_max_pereimenovat

# Предлагаю к рассмотрению мою реализацию алгоритма, немного модифицировал твой.
# Получился сильно медленнее твоего из-за операции удаления элемента из списка.
def sieve_of_eratosthenes_luzin(n: int) -> int:
    """ 
        Функция печатает простые числа в интервале от 2 до n.
        Реализация А.Лузина.
    """
    primes = list(range(2, n))
    k_max_pereimenovat = 0
    for k in primes:
        print(k, end=' ')
        
        for i in range(k, n // k + 1):
            if i*k in primes:
                primes.remove(i*k)
                k_max_pereimenovat = k
    
    return k_max_pereimenovat

# Отделил весь остальной интерфейс по вводу/выводу данных от самого решета Эратосфена.
# Если делать по-красоте, то функция sieve_of_eratosthenes должна вернуть список простых чисел (ну и k_max_pereimenovat если он нужен) а выводом она заниматься не должна.
# Аргументы почему это было бы лучше:
# 1. Принцип единой ответственности  - лучше стараться делать так, чтобы функция или метод делали что-то одно, вычисление и вывод на экран это два разных действия. 
#    Если по возможности следовать этому принципу, то код получается проще для чтения и для поддержки. 
# 2. На такую функцию было бы легко написать юнит-тесты.
# 3. Такую функцию можно было бы импортировать в каком-то другом проекте где нужны простые числа. Она запросто может стать библиотечной функцией.
# 4. Такую функцию легко заменить на какую-то другую реализацию. 

# P.S. В целом такие функция называют "чистыми", то есть функции без побочных эффектов, побочным эффектом тут является print. Чистая функция похожа на функцию в математике, 
# у нее есть вход и выход и для одинаковых входов она всегда возвращает одинаковый выход. "Грязные" функции имет побочные эффекты - это либо запись/чтение в файл, 
# либо ввод/вывод с консоли, взаимодействие с БД, выход в интернет, короче любое взаимодействие со внешним миром делает функцию "грязной". По возможности,
# лучше стараться делать чистые функции, хотя за это больше топит уже функциональная парадигма программирования, но эти же аргументы верны для любой парадигмы. 
# Чистую функцию легко тестировать, легко переиспользовать, для них даже иногда можно строго математически доказывать правильность алгоритма. В реальном мире полностью на чистых
# функциях программировать не получится, иначе программа никак не будет взаимодействовать с внешним миром, но "чистое" лучше всегда стараться отделять от "грязного".
# Хотя вот в языке Haskell они там все на чистых функциях делают, а взаимодействие с внешним миром происходит через монады, но это уже off-topic )
 
def main():

    # Заменил все пустые print на \n в строках, хотя это больше вкусовщина
    print("\nДоброго времени суток! Это - первая нормальная полностью мной написанная на Python'e программа!")
    print("Это программа реализует алгоритм решета Эратосфена по выписыванию всех простых чисел в диапазане от 2 до n включительно")
    print("(число n задаётся пользователем).\n")

    n = int(input("Введите n: ")) #  Пробел перед двоеточием не ставится
    # TODO: тут ннада сделать try :)
    # Для вещей которые хочется сделать потом (техдолг) используется стандартый маркер TODO в комментариях. Некоторые IDE (как pycharm) его понимают и выделяют цветом. 
    
    # Сразу выводим результат, накапливать числа в строке, а потом выводить в целом не самая лучшая идея.
    print(f"\nСписок простых чисел от 2 до {n}:", end=' ')
    k_max_pereimenovat = sieve_of_eratosthenes(n)
    print(f"\nk_max = {k_max_pereimenovat}")
    
    print('\nАлгоритм Лузина')
    print(f"Список простых чисел от 2 до {n}:", end=' ')
    k_max_pereimenovat = sieve_of_eratosthenes_luzin(n)
    print(f"\nk_max = {k_max_pereimenovat}")
    input()    

if __name__ == '__main__':
    main()